<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Table Generator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const Download = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>;
    const Upload = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>;
    const Copy = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>;
    const Plus = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>;
    const Trash2 = ({ size = 16 }) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>;
    const Undo = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 7v6h6M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>;
    const Redo = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 7v6h-6M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"/></svg>;
    const Save = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>;
    const Moon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>;
    const Sun = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>;
    const Printer = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></svg>;
    const FileText = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>;

    function TableGenerator() {
      const [tableName, setTableName] = useState('Data Table');
      const [tableDescription, setTableDescription] = useState('');
      const [rows, setRows] = useState(5);
      const [cols, setCols] = useState(4);
      const [headers, setHeaders] = useState(['Column 1', 'Column 2', 'Column 3', 'Column 4']);
      const [data, setData] = useState(Array(5).fill(null).map(() => Array(4).fill('')));
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);
      const [darkMode, setDarkMode] = useState(false);
      const [searchTerm, setSearchTerm] = useState('');
      const [sortConfig, setSortConfig] = useState({ column: null, direction: 'asc' });
      const [selectedCell, setSelectedCell] = useState(null);
      const [cellStyles, setCellStyles] = useState({});
      const csvInputRef = useRef(null);
      const latexInputRef = useRef(null);

      useEffect(() => {
        loadFromStorage();
      }, []);

      const saveToHistory = (newData, newHeaders) => {
        const newHistory = history.slice(0, historyIndex + 1);
        newHistory.push({ data: newData, headers: newHeaders });
        setHistory(newHistory);
        setHistoryIndex(newHistory.length - 1);
      };

      const loadFromStorage = () => {
        try {
          const saved = localStorage.getItem('table-data');
          if (saved) {
            const parsed = JSON.parse(saved);
            setTableName(parsed.tableName || 'Data Table');
            setTableDescription(parsed.tableDescription || '');
            setHeaders(parsed.headers || headers);
            setData(parsed.data || data);
            setRows(parsed.data?.length || 5);
            setCols(parsed.headers?.length || 4);
            setCellStyles(parsed.cellStyles || {});
          }
        } catch (error) {
          console.log('No saved data found');
        }
      };

      const saveToStorage = () => {
        try {
          localStorage.setItem('table-data', JSON.stringify({
            tableName,
            tableDescription,
            headers,
            data,
            cellStyles
          }));
          alert('Table saved successfully!');
        } catch (error) {
          console.error('Save failed:', error);
          alert('Failed to save table');
        }
      };

      const handleRowsChange = (e) => {
        const newRows = Math.max(1, parseInt(e.target.value) || 1);
        setRows(newRows);
        let newData = [...data];
        if (newRows > data.length) {
          for (let i = 0; i < newRows - data.length; i++) {
            newData.push(Array(cols).fill(''));
          }
        } else {
          newData = newData.slice(0, newRows);
        }
        setData(newData);
        saveToHistory(newData, headers);
      };

      const handleColsChange = (e) => {
        const newCols = Math.max(1, parseInt(e.target.value) || 1);
        setCols(newCols);
        let newHeaders = [...headers];
        let newData = [...data];
        if (newCols > headers.length) {
          for (let i = 0; i < newCols - headers.length; i++) {
            newHeaders.push(`Column ${headers.length + i + 1}`);
          }
          newData = newData.map(row => {
            const newRow = [...row];
            for (let i = 0; i < newCols - row.length; i++) {
              newRow.push('');
            }
            return newRow;
          });
        } else {
          newHeaders = newHeaders.slice(0, newCols);
          newData = newData.map(row => row.slice(0, newCols));
        }
        setHeaders(newHeaders);
        setData(newData);
        saveToHistory(newData, newHeaders);
      };

      const addRow = () => {
        const newData = [...data, Array(cols).fill('')];
        setData(newData);
        setRows(rows + 1);
        saveToHistory(newData, headers);
      };

      const deleteRow = (idx) => {
        if (data.length > 1) {
          const newData = data.filter((_, i) => i !== idx);
          setData(newData);
          setRows(rows - 1);
          saveToHistory(newData, headers);
        }
      };

      const addColumn = () => {
        const newHeaders = [...headers, `Column ${headers.length + 1}`];
        const newData = data.map(row => [...row, '']);
        setHeaders(newHeaders);
        setData(newData);
        setCols(cols + 1);
        saveToHistory(newData, newHeaders);
      };

      const deleteColumn = (idx) => {
        if (headers.length > 1) {
          const newHeaders = headers.filter((_, i) => i !== idx);
          const newData = data.map(row => row.filter((_, i) => i !== idx));
          setHeaders(newHeaders);
          setData(newData);
          setCols(cols - 1);
          saveToHistory(newData, newHeaders);
        }
      };

      const undo = () => {
        if (historyIndex > 0) {
          const newIndex = historyIndex - 1;
          const state = history[newIndex];
          setData(state.data);
          setHeaders(state.headers);
          setHistoryIndex(newIndex);
        }
      };

      const redo = () => {
        if (historyIndex < history.length - 1) {
          const newIndex = historyIndex + 1;
          const state = history[newIndex];
          setData(state.data);
          setHeaders(state.headers);
          setHistoryIndex(newIndex);
        }
      };

      const sortColumn = (colIdx) => {
        const direction = sortConfig.column === colIdx && sortConfig.direction === 'asc' ? 'desc' : 'asc';
        const sortedData = [...data].sort((a, b) => {
          const aVal = a[colIdx];
          const bVal = b[colIdx];
          const comparison = aVal.localeCompare(bVal, undefined, { numeric: true });
          return direction === 'asc' ? comparison : -comparison;
        });
        setData(sortedData);
        setSortConfig({ column: colIdx, direction });
        saveToHistory(sortedData, headers);
      };

      const exportToCSV = () => {
        let csv = '';
        if (tableDescription) {
          csv += `# ${tableName}\n# ${tableDescription}\n#\n`;
        }
        csv += headers.join(',') + '\n';
        data.forEach(row => csv += row.map(cell => `"${cell}"`).join(',') + '\n');
        downloadFile(csv, tableName.replace(/\s+/g, '_') + '.csv', 'text/csv');
      };

      const exportToLaTeX = () => {
        let latex = '\\begin{table}[h]\n\\centering\n';
        latex += `\\caption{${tableName}`;
        if (tableDescription) {
          latex += `. ${tableDescription}`;
        }
        latex += '}\n';
        latex += `\\begin{tabular}{|${'c|'.repeat(cols)}}\n\\hline\n`;
        latex += headers.join(' & ') + ' \\\\\n\\hline\n';
        data.forEach(row => {
          latex += row.map(cell => cell.replace(/[&%$#_{}~^\\]/g, '\\$&')).join(' & ') + ' \\\\\n\\hline\n';
        });
        latex += '\\end{tabular}\n';
        if (tableDescription) {
          latex += `\\label{tab:${tableName.toLowerCase().replace(/\s+/g, '_')}}\n`;
        }
        latex += '\\end{table}';
        downloadFile(latex, tableName.replace(/\s+/g, '_') + '.tex', 'text/plain');
      };

      const exportToPDF = () => {
        const printWindow = window.open('', '_blank');
        const html = `<!DOCTYPE html><html><head><title>${tableName}</title><style>body{font-family:Arial,sans-serif;padding:20px}h1{text-align:center;margin-bottom:10px}.description{text-align:center;color:#666;margin-bottom:20px;font-style:italic}table{width:100%;border-collapse:collapse;margin:20px 0}th,td{border:1px solid #000;padding:8px;text-align:left}th{background-color:#f0f0f0;font-weight:bold}</style></head><body><h1>${tableName}</h1>${tableDescription ? `<div class="description">${tableDescription}</div>` : ''}<table><thead><tr><th>#</th>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead><tbody>${data.map((row, i) => `<tr><td>${i + 1}</td>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('')}</tbody></table></body></html>`;
        printWindow.document.write(html);
        printWindow.document.close();
        printWindow.print();
      };

      const importCSV = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          const text = event.target.result;
          const lines = text.split('\n').filter(line => line.trim());
          if (lines.length === 0) return;
          let startIdx = 0;
          let desc = '';
          while (startIdx < lines.length && lines[startIdx].trim().startsWith('#')) {
            const comment = lines[startIdx].trim().substring(1).trim();
            if (comment && !comment.match(/^[-=]+$/)) {
              desc += (desc ? ' ' : '') + comment;
            }
            startIdx++;
          }
          if (desc) setTableDescription(desc);
          const newHeaders = lines[startIdx].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
          const newData = lines.slice(startIdx + 1).map(line => line.split(',').map(cell => cell.trim().replace(/^"|"$/g, '')));
          setHeaders(newHeaders);
          setData(newData);
          setCols(newHeaders.length);
          setRows(newData.length);
          saveToHistory(newData, newHeaders);
        };
        reader.readAsText(file);
      };

      const importLaTeX = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          const text = event.target.result;
          const captionMatch = text.match(/\\caption\{([^}]+)\}/);
          if (captionMatch) {
            const caption = captionMatch[1];
            const parts = caption.split('.');
            if (parts.length > 1) {
              setTableName(parts[0].trim());
              setTableDescription(parts.slice(1).join('.').trim());
            } else {
              setTableName(caption.trim());
            }
          }
          const tabularMatch = text.match(/\\begin\{tabular\}.*?\n(.*?)\\end\{tabular\}/s);
          if (!tabularMatch) {
            alert('No tabular environment found in LaTeX file');
            return;
          }
          const tableContent = tabularMatch[1];
          const rows = tableContent.split('\\\\').map(row => row.replace(/\\hline/g, '').trim()).filter(row => row);
          if (rows.length === 0) return;
          const newHeaders = rows[0].split('&').map(h => h.trim());
          const newData = rows.slice(1).map(row => row.split('&').map(cell => cell.trim().replace(/\\([&%$#_{}~^\\])/g, '$1')));
          setHeaders(newHeaders);
          setData(newData);
          setCols(newHeaders.length);
          setRows(newData.length);
          saveToHistory(newData, newHeaders);
        };
        reader.readAsText(file);
      };

      const copyToClipboard = async () => {
        let text = tableName + '\n';
        if (tableDescription) text += tableDescription + '\n';
        text += '\n' + headers.join('\t') + '\n';
        text += data.map(row => row.join('\t')).join('\n');
        try {
          await navigator.clipboard.writeText(text);
          alert('Table copied to clipboard!');
        } catch (err) {
          alert('Failed to copy to clipboard');
        }
      };

      const downloadFile = (content, filename, type) => {
        const blob = new Blob([content], { type });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        window.URL.revokeObjectURL(url);
      };

      const toggleCellStyle = (rowIdx, colIdx, style) => {
        const key = `${rowIdx}-${colIdx}`;
        const current = cellStyles[key] || {};
        setCellStyles({...cellStyles, [key]: {...current, [style]: !current[style]}});
      };

      const getCellStyle = (rowIdx, colIdx) => {
        const key = `${rowIdx}-${colIdx}`;
        const styles = cellStyles[key] || {};
        return {
          fontWeight: styles.bold ? 'bold' : 'normal',
          backgroundColor: styles.highlight ? '#fef08a' : 'transparent',
          textAlign: styles.center ? 'center' : 'left'
        };
      };

      const filteredData = data.map((row, idx) => ({
        row, idx,
        matches: searchTerm ? row.some(cell => cell.toLowerCase().includes(searchTerm.toLowerCase())) : true
      })).filter(item => item.matches);

      const bgClass = darkMode ? 'bg-gray-900' : 'bg-gradient-to-br from-blue-50 to-indigo-100';
      const cardBg = darkMode ? 'bg-gray-800' : 'bg-white';
      const textClass = darkMode ? 'text-white' : 'text-gray-800';
      const inputClass = darkMode ? 'bg-gray-700 text-white border-gray-600' : 'bg-white border-gray-300';

      return (
        <div className={`min-h-screen ${bgClass} p-4 md:p-8 transition-colors`}>
          <div className="max-w-7xl mx-auto">
            <div className={`${cardBg} rounded-lg shadow-lg p-4 md:p-6 mb-6`}>
              <div className="flex flex-wrap items-center justify-between mb-6 gap-4">
                <h1 className={`text-2xl md:text-3xl font-bold ${textClass}`}>Advanced Table Generator</h1>
                <button onClick={() => setDarkMode(!darkMode)} className="p-2 rounded-lg hover:bg-gray-200">
                  {darkMode ? <Sun /> : <Moon />}
                </button>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <div>
                  <label className={`block text-sm font-medium ${textClass} mb-2`}>Table Name</label>
                  <input type="text" value={tableName} onChange={(e) => setTableName(e.target.value)} className={`w-full px-3 py-2 border rounded-md ${inputClass}`} />
                </div>
                <div>
                  <label className={`block text-sm font-medium ${textClass} mb-2`}>Search</label>
                  <input type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Filter data..." className={`w-full px-3 py-2 border rounded-md ${inputClass}`} />
                </div>
              </div>
              <div className="mb-6">
                <label className={`block text-sm font-medium ${textClass} mb-2`}>Table Description</label>
                <textarea value={tableDescription} onChange={(e) => setTableDescription(e.target.value)} placeholder="Add a description for your table (exported in all formats)..." rows="3" className={`w-full px-3 py-2 border rounded-md ${inputClass}`} />
              </div>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                <div>
                  <label className={`block text-sm font-medium ${textClass} mb-2`}>Rows</label>
                  <input type="number" min="1" value={rows} onChange={handleRowsChange} className={`w-full px-3 py-2 border rounded-md ${inputClass}`} />
                </div>
                <div>
                  <label className={`block text-sm font-medium ${textClass} mb-2`}>Columns</label>
                  <input type="number" min="1" value={cols} onChange={handleColsChange} className={`w-full px-3 py-2 border rounded-md ${inputClass}`} />
                </div>
              </div>
              <div className="flex flex-wrap gap-2 mb-4">
                <button onClick={addRow} className="flex items-center gap-1 px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 text-sm"><Plus /> Row</button>
                <button onClick={addColumn} className="flex items-center gap-1 px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 text-sm"><Plus /> Column</button>
                <button onClick={undo} disabled={historyIndex <= 0} className="flex items-center gap-1 px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 disabled:opacity-50 text-sm"><Undo /> Undo</button>
                <button onClick={redo} disabled={historyIndex >= history.length - 1} className="flex items-center gap-1 px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 disabled:opacity-50 text-sm"><Redo /> Redo</button>
                <button onClick={saveToStorage} className="flex items-center gap-1 px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm"><Save /> Save</button>
                <button onClick={copyToClipboard} className="flex items-center gap-1 px-3 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-sm"><Copy /> Copy</button>
              </div>
              <div className="mb-4">
                <h3 className={`text-sm font-semibold ${textClass} mb-2`}>Export</h3>
                <div className="flex flex-wrap gap-2">
                  <button onClick={exportToCSV} className="flex items-center gap-1 px-3 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 text-sm"><Download /> CSV</button>
                  <button onClick={exportToLaTeX} className="flex items-center gap-1 px-3 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 text-sm"><FileText /> LaTeX</button>
                  <button onClick={exportToPDF} className="flex items-center gap-1 px-3 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 text-sm"><Printer /> PDF</button>
                </div>
              </div>
              <div>
                <h3 className={`text-sm font-semibold ${textClass} mb-2`}>Import</h3>
                <div className="flex flex-wrap gap-2">
                  <input ref={csvInputRef} type="file" accept=".csv" onChange={importCSV} className="hidden" />
                  <button onClick={() => csvInputRef.current?.click()} className="flex items-center gap-1 px-3 py-2 bg-orange-500 text-white rounded-md hover:bg-orange-600 text-sm"><Upload /> CSV</button>
                  <input ref={latexInputRef} type="file" accept=".tex" onChange={importLaTeX} className="hidden" />
                  <button onClick={() => latexInputRef.current?.click()} className="flex items-center gap-1 px-3 py-2 bg-orange-500 text-white rounded-md hover:bg-orange-600 text-sm"><Upload /> LaTeX</button>
                </div>
              </div>
            </div>
            {selectedCell && (
              <div className={`${cardBg} rounded-lg shadow-lg p-4 mb-6`}>
                <h3 className={`text-sm font-semibold ${textClass} mb-3`}>Cell Formatting (Row {selectedCell.row + 1}, Col {selectedCell.col + 1})</h3>
                <div className="flex flex-wrap gap-2">
                  <button onClick={() => toggleCellStyle(selectedCell.row, selectedCell.col, 'bold')} className="px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600">Bold</button>
                  <button onClick={() => toggleCellStyle(selectedCell.row, selectedCell.col, 'highlight')} className="px-3 py-1 bg-yellow-500 text-white rounded text-sm hover:bg-yellow-600">Highlight</button>
                  <button onClick={() => toggleCellStyle(selectedCell.row, selectedCell.col, 'center')} className="px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600">Center</button>
                </div>
              </div>
            )}
            <div className={`${cardBg} rounded-lg shadow-lg p-4 md:p-6`}>
              <h2 className={`text-xl font-semibold ${textClass} mb-4`}>Table Preview</h2>
              <div className="overflow-x-auto">
                <table className={`w-full border-collapse border ${darkMode ? 'border-gray-600' : 'border-gray-300'}`}>
                  <thead>
                    <tr className={darkMode ? 'bg-gray-700' : 'bg-gray-100'}>
                      <th className={`border ${darkMode ? 'border-gray-600' : 'border-gray-300'} px-2 md:px-4 py-2 text-sm`}>#</th>
                      {headers.map((h, i) => (
                        <th key={i} className={`border ${darkMode ? 'border-gray-600' : 'border-gray-300'} px-2 md:px-4 py-2 text-sm`}>
                          <div className="flex items-center justify-between gap-2">
                            <input type="text" value={h} onChange={(e) => {const newHeaders = [...headers]; newHeaders[i] = e.target.value; setHeaders(newHeaders);}} className={`flex-1 px-2 py-1 text-center bg-transparent ${textClass}`} />
                            <button onClick={() => sortColumn(i)} className="text-xs hover:text-blue-500">â†•</button>
                            <button onClick={() => deleteColumn(i)} className="text-xs text-red-500 hover:text-red-700"><Trash2 size={14} /></button>
                          </div>
                        </th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {filteredData.map(({ row, idx }) => (
                      <tr key={idx} className={darkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-50'}>
                        <td className={`border ${darkMode ? 'border-gray-600 bg-gray-700' : 'border-gray-300 bg-gray-50'} px-2 md:px-4 py-2 text-center font-medium text-sm`}>
                          <div className="flex items-center justify-center gap-2">
                            {idx + 1}
                            <button onClick={() => deleteRow(idx)} className="text-xs text-red-500 hover:text-red-700"><Trash2 size={14} /></button>
                          </div>
                        </td>
                        {row.map((cell, colIdx) => (
                          <td key={colIdx} className={`border ${darkMode ? 'border-gray-600' : 'border-gray-300'} px-2 md:px-4 py-2 text-sm`}>
                            <input type="text" value={cell} onChange={(e) => {const newData = [...data]; newData[idx][colIdx] = e.target.value; setData(newData);}} onFocus={() => setSelectedCell({ row: idx, col: colIdx })} style={getCellStyle(idx, colIdx)} className={`w-full px-2 py-1 bg-transparent ${textClass}`} />
                          </td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<TableGenerator />);
  </script>
</body>
</html>
