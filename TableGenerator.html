import React, { useState, useEffect, useRef } from 'react';
import { Download, Upload, Copy, Plus, Trash2, Undo, Redo, Save, Moon, Sun, Printer, FileText } from 'lucide-react';

function TableGenerator() {
  const [tableName, setTableName] = useState('Data Table');
  const [tableDescription, setTableDescription] = useState('');
  const [rows, setRows] = useState(5);
  const [cols, setCols] = useState(4);
  const [headers, setHeaders] = useState(['Column 1', 'Column 2', 'Column 3', 'Column 4']);
  const [data, setData] = useState(Array(5).fill(null).map(() => Array(4).fill('')));
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [darkMode, setDarkMode] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [sortConfig, setSortConfig] = useState({ column: null, direction: 'asc' });
  const [selectedCell, setSelectedCell] = useState(null);
  const [cellStyles, setCellStyles] = useState({});
  const csvInputRef = useRef(null);
  const latexInputRef = useRef(null);

  useEffect(() => {
    loadFromStorage();
  }, []);

  const saveToHistory = (newData, newHeaders) => {
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push({ data: newData, headers: newHeaders });
    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  };

  const loadFromStorage = async () => {
    try {
      const result = await window.storage.get('table-data');
      if (result) {
        const saved = JSON.parse(result.value);
        setTableName(saved.tableName || 'Data Table');
        setTableDescription(saved.tableDescription || '');
        setHeaders(saved.headers || headers);
        setData(saved.data || data);
        setRows(saved.data?.length || 5);
        setCols(saved.headers?.length || 4);
        setCellStyles(saved.cellStyles || {});
      }
    } catch (error) {
      console.log('No saved data found');
    }
  };

  const saveToStorage = async () => {
    try {
      await window.storage.set('table-data', JSON.stringify({
        tableName,
        tableDescription,
        headers,
        data,
        cellStyles
      }));
      alert('Table saved successfully!');
    } catch (error) {
      console.error('Save failed:', error);
      alert('Failed to save table');
    }
  };

  const handleRowsChange = (e) => {
    const newRows = Math.max(1, parseInt(e.target.value) || 1);
    setRows(newRows);
    
    let newData = [...data];
    if (newRows > data.length) {
      const rowsToAdd = newRows - data.length;
      for (let i = 0; i < rowsToAdd; i++) {
        newData.push(Array(cols).fill(''));
      }
    } else {
      newData = newData.slice(0, newRows);
    }
    setData(newData);
    saveToHistory(newData, headers);
  };

  const handleColsChange = (e) => {
    const newCols = Math.max(1, parseInt(e.target.value) || 1);
    setCols(newCols);
    
    let newHeaders = [...headers];
    let newData = [...data];
    
    if (newCols > headers.length) {
      const colsToAdd = newCols - headers.length;
      for (let i = 0; i < colsToAdd; i++) {
        newHeaders.push(`Column ${headers.length + i + 1}`);
      }
      newData = newData.map(row => {
        const newRow = [...row];
        for (let i = 0; i < colsToAdd; i++) {
          newRow.push('');
        }
        return newRow;
      });
    } else {
      newHeaders = newHeaders.slice(0, newCols);
      newData = newData.map(row => row.slice(0, newCols));
    }
    
    setHeaders(newHeaders);
    setData(newData);
    saveToHistory(newData, newHeaders);
  };

  const addRow = () => {
    const newData = [...data, Array(cols).fill('')];
    setData(newData);
    setRows(rows + 1);
    saveToHistory(newData, headers);
  };

  const deleteRow = (idx) => {
    if (data.length > 1) {
      const newData = data.filter((_, i) => i !== idx);
      setData(newData);
      setRows(rows - 1);
      saveToHistory(newData, headers);
    }
  };

  const addColumn = () => {
    const newHeaders = [...headers, `Column ${headers.length + 1}`];
    const newData = data.map(row => [...row, '']);
    setHeaders(newHeaders);
    setData(newData);
    setCols(cols + 1);
    saveToHistory(newData, newHeaders);
  };

  const deleteColumn = (idx) => {
    if (headers.length > 1) {
      const newHeaders = headers.filter((_, i) => i !== idx);
      const newData = data.map(row => row.filter((_, i) => i !== idx));
      setHeaders(newHeaders);
      setData(newData);
      setCols(cols - 1);
      saveToHistory(newData, newHeaders);
    }
  };

  const undo = () => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      const state = history[newIndex];
      setData(state.data);
      setHeaders(state.headers);
      setHistoryIndex(newIndex);
    }
  };

  const redo = () => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      const state = history[newIndex];
      setData(state.data);
      setHeaders(state.headers);
      setHistoryIndex(newIndex);
    }
  };

  const sortColumn = (colIdx) => {
    const direction = sortConfig.column === colIdx && sortConfig.direction === 'asc' ? 'desc' : 'asc';
    const sortedData = [...data].sort((a, b) => {
      const aVal = a[colIdx];
      const bVal = b[colIdx];
      const comparison = aVal.localeCompare(bVal, undefined, { numeric: true });
      return direction === 'asc' ? comparison : -comparison;
    });
    setData(sortedData);
    setSortConfig({ column: colIdx, direction });
    saveToHistory(sortedData, headers);
  };

  const exportToCSV = () => {
    let csv = '';
    if (tableDescription) {
      csv += `# ${tableName}\n# ${tableDescription}\n#\n`;
    }
    csv += headers.join(',') + '\n';
    data.forEach(row => csv += row.map(cell => `"${cell}"`).join(',') + '\n');
    downloadFile(csv, tableName.replace(/\s+/g, '_') + '.csv', 'text/csv');
  };

  const exportToLaTeX = () => {
    let latex = '\\begin{table}[h]\n\\centering\n';
    latex += `\\caption{${tableName}`;
    if (tableDescription) {
      latex += `. ${tableDescription}`;
    }
    latex += '}\n';
    latex += `\\begin{tabular}{|${'c|'.repeat(cols)}}\n\\hline\n`;
    latex += headers.join(' & ') + ' \\\\\n\\hline\n';
    data.forEach(row => {
      latex += row.map(cell => cell.replace(/[&%$#_{}~^\\]/g, '\\$&')).join(' & ') + ' \\\\\n\\hline\n';
    });
    latex += '\\end{tabular}\n';
    if (tableDescription) {
      latex += `\\label{tab:${tableName.toLowerCase().replace(/\s+/g, '_')}}\n`;
    }
    latex += '\\end{table}';
    downloadFile(latex, tableName.replace(/\s+/g, '_') + '.tex', 'text/plain');
  };

  const exportToPDF = () => {
    const printWindow = window.open('', '_blank');
    const html = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>${tableName}</title>
        <style>
          body { font-family: Arial, sans-serif; padding: 20px; }
          h1 { text-align: center; margin-bottom: 10px; }
          .description { text-align: center; color: #666; margin-bottom: 20px; font-style: italic; }
          table { width: 100%; border-collapse: collapse; margin: 20px 0; }
          th, td { border: 1px solid #000; padding: 8px; text-align: left; }
          th { background-color: #f0f0f0; font-weight: bold; }
        </style>
      </head>
      <body>
        <h1>${tableName}</h1>
        ${tableDescription ? `<div class="description">${tableDescription}</div>` : ''}
        <table>
          <thead><tr><th>#</th>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>
          <tbody>
            ${data.map((row, i) => `<tr><td>${i + 1}</td>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('')}
          </tbody>
        </table>
      </body>
      </html>
    `;
    printWindow.document.write(html);
    printWindow.document.close();
    printWindow.print();
  };

  const importCSV = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const text = event.target.result;
      const lines = text.split('\n').filter(line => line.trim());
      if (lines.length === 0) return;
      
      let startIdx = 0;
      let desc = '';
      
      // Check for description comments at the start
      while (startIdx < lines.length && lines[startIdx].trim().startsWith('#')) {
        const comment = lines[startIdx].trim().substring(1).trim();
        if (comment && !comment.match(/^[-=]+$/)) {
          desc += (desc ? ' ' : '') + comment;
        }
        startIdx++;
      }
      
      if (desc) setTableDescription(desc);
      
      const newHeaders = lines[startIdx].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
      const newData = lines.slice(startIdx + 1).map(line => 
        line.split(',').map(cell => cell.trim().replace(/^"|"$/g, ''))
      );
      
      setHeaders(newHeaders);
      setData(newData);
      setCols(newHeaders.length);
      setRows(newData.length);
      saveToHistory(newData, newHeaders);
    };
    reader.readAsText(file);
  };

  const importLaTeX = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const text = event.target.result;
      
      // Extract caption/description
      const captionMatch = text.match(/\\caption\{([^}]+)\}/);
      if (captionMatch) {
        const caption = captionMatch[1];
        const parts = caption.split('.');
        if (parts.length > 1) {
          setTableName(parts[0].trim());
          setTableDescription(parts.slice(1).join('.').trim());
        } else {
          setTableName(caption.trim());
        }
      }
      
      // Extract table data
      const tabularMatch = text.match(/\\begin\{tabular\}.*?\n(.*?)\\end\{tabular\}/s);
      if (!tabularMatch) {
        alert('No tabular environment found in LaTeX file');
        return;
      }
      
      const tableContent = tabularMatch[1];
      const rows = tableContent.split('\\\\').map(row => 
        row.replace(/\\hline/g, '').trim()
      ).filter(row => row);
      
      if (rows.length === 0) return;
      
      // First row is headers
      const newHeaders = rows[0].split('&').map(h => h.trim());
      const newData = rows.slice(1).map(row => 
        row.split('&').map(cell => cell.trim().replace(/\\([&%$#_{}~^\\])/g, '$1'))
      );
      
      setHeaders(newHeaders);
      setData(newData);
      setCols(newHeaders.length);
      setRows(newData.length);
      saveToHistory(newData, newHeaders);
    };
    reader.readAsText(file);
  };

  const copyToClipboard = async () => {
    let text = tableName + '\n';
    if (tableDescription) {
      text += tableDescription + '\n';
    }
    text += '\n' + headers.join('\t') + '\n';
    text += data.map(row => row.join('\t')).join('\n');
    
    try {
      await navigator.clipboard.writeText(text);
      alert('Table copied to clipboard!');
    } catch (err) {
      alert('Failed to copy to clipboard');
    }
  };

  const downloadFile = (content, filename, type) => {
    const blob = new Blob([content], { type });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const toggleCellStyle = (rowIdx, colIdx, style) => {
    const key = `${rowIdx}-${colIdx}`;
    const current = cellStyles[key] || {};
    setCellStyles({
      ...cellStyles,
      [key]: { ...current, [style]: !current[style] }
    });
  };

  const getCellStyle = (rowIdx, colIdx) => {
    const key = `${rowIdx}-${colIdx}`;
    const styles = cellStyles[key] || {};
    return {
      fontWeight: styles.bold ? 'bold' : 'normal',
      backgroundColor: styles.highlight ? '#fef08a' : 'transparent',
      textAlign: styles.center ? 'center' : 'left'
    };
  };

  const filteredData = data.map((row, idx) => ({
    row,
    idx,
    matches: searchTerm ? row.some(cell => 
      cell.toLowerCase().includes(searchTerm.toLowerCase())
    ) : true
  })).filter(item => item.matches);

  const bgClass = darkMode ? 'bg-gray-900' : 'bg-gradient-to-br from-blue-50 to-indigo-100';
  const cardBg = darkMode ? 'bg-gray-800' : 'bg-white';
  const textClass = darkMode ? 'text-white' : 'text-gray-800';
  const inputClass = darkMode ? 'bg-gray-700 text-white border-gray-600' : 'bg-white border-gray-300';

  return (
    <div className={`min-h-screen ${bgClass} p-4 md:p-8 transition-colors`}>
      <div className="max-w-7xl mx-auto">
        <div className={`${cardBg} rounded-lg shadow-lg p-4 md:p-6 mb-6`}>
          <div className="flex flex-wrap items-center justify-between mb-6 gap-4">
            <h1 className={`text-2xl md:text-3xl font-bold ${textClass}`}>Advanced Table Generator</h1>
            <button onClick={() => setDarkMode(!darkMode)} className="p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700">
              {darkMode ? <Sun size={20} /> : <Moon size={20} />}
            </button>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div>
              <label className={`block text-sm font-medium ${textClass} mb-2`}>Table Name</label>
              <input 
                type="text" 
                value={tableName} 
                onChange={(e) => setTableName(e.target.value)}
                className={`w-full px-3 py-2 border rounded-md ${inputClass}`}
              />
            </div>
            <div>
              <label className={`block text-sm font-medium ${textClass} mb-2`}>Search</label>
              <input 
                type="text" 
                value={searchTerm} 
                onChange={(e) => setSearchTerm(e.target.value)}
                placeholder="Filter data..."
                className={`w-full px-3 py-2 border rounded-md ${inputClass}`}
              />
            </div>
          </div>

          <div className="mb-6">
            <label className={`block text-sm font-medium ${textClass} mb-2`}>Table Description</label>
            <textarea 
              value={tableDescription} 
              onChange={(e) => setTableDescription(e.target.value)}
              placeholder="Add a description for your table (exported in all formats)..."
              rows="3"
              className={`w-full px-3 py-2 border rounded-md ${inputClass}`}
            />
          </div>
          
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
            <div>
              <label className={`block text-sm font-medium ${textClass} mb-2`}>Rows</label>
              <input 
                type="number" 
                min="1"
                value={rows} 
                onChange={handleRowsChange}
                className={`w-full px-3 py-2 border rounded-md ${inputClass}`}
              />
            </div>
            <div>
              <label className={`block text-sm font-medium ${textClass} mb-2`}>Columns</label>
              <input 
                type="number" 
                min="1"
                value={cols} 
                onChange={handleColsChange}
                className={`w-full px-3 py-2 border rounded-md ${inputClass}`}
              />
            </div>
          </div>
          
          <div className="flex flex-wrap gap-2 mb-4">
            <button onClick={addRow} className="flex items-center gap-1 px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 text-sm">
              <Plus size={16} /> Row
            </button>
            <button onClick={addColumn} className="flex items-center gap-1 px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 text-sm">
              <Plus size={16} /> Column
            </button>
            <button onClick={undo} disabled={historyIndex <= 0} className="flex items-center gap-1 px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 disabled:opacity-50 text-sm">
              <Undo size={16} /> Undo
            </button>
            <button onClick={redo} disabled={historyIndex >= history.length - 1} className="flex items-center gap-1 px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 disabled:opacity-50 text-sm">
              <Redo size={16} /> Redo
            </button>
            <button onClick={saveToStorage} className="flex items-center gap-1 px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm">
              <Save size={16} /> Save
            </button>
            <button onClick={copyToClipboard} className="flex items-center gap-1 px-3 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 text-sm">
              <Copy size={16} /> Copy
            </button>
          </div>

          <div className="mb-4">
            <h3 className={`text-sm font-semibold ${textClass} mb-2`}>Export</h3>
            <div className="flex flex-wrap gap-2">
              <button onClick={exportToCSV} className="flex items-center gap-1 px-3 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 text-sm">
                <Download size={16} /> CSV
              </button>
              <button onClick={exportToLaTeX} className="flex items-center gap-1 px-3 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 text-sm">
                <FileText size={16} /> LaTeX
              </button>
              <button onClick={exportToPDF} className="flex items-center gap-1 px-3 py-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 text-sm">
                <Printer size={16} /> PDF
              </button>
            </div>
          </div>

          <div>
            <h3 className={`text-sm font-semibold ${textClass} mb-2`}>Import</h3>
            <div className="flex flex-wrap gap-2">
              <input ref={csvInputRef} type="file" accept=".csv" onChange={importCSV} className="hidden" />
              <button onClick={() => csvInputRef.current?.click()} className="flex items-center gap-1 px-3 py-2 bg-orange-500 text-white rounded-md hover:bg-orange-600 text-sm">
                <Upload size={16} /> CSV
              </button>
              <input ref={latexInputRef} type="file" accept=".tex" onChange={importLaTeX} className="hidden" />
              <button onClick={() => latexInputRef.current?.click()} className="flex items-center gap-1 px-3 py-2 bg-orange-500 text-white rounded-md hover:bg-orange-600 text-sm">
                <Upload size={16} /> LaTeX
              </button>
            </div>
          </div>
        </div>
        
        {selectedCell && (
          <div className={`${cardBg} rounded-lg shadow-lg p-4 mb-6`}>
            <h3 className={`text-sm font-semibold ${textClass} mb-3`}>Cell Formatting (Row {selectedCell.row + 1}, Col {selectedCell.col + 1})</h3>
            <div className="flex flex-wrap gap-2">
              <button onClick={() => toggleCellStyle(selectedCell.row, selectedCell.col, 'bold')} className="px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600">
                Bold
              </button>
              <button onClick={() => toggleCellStyle(selectedCell.row, selectedCell.col, 'highlight')} className="px-3 py-1 bg-yellow-500 text-white rounded text-sm hover:bg-yellow-600">
                Highlight
              </button>
              <button onClick={() => toggleCellStyle(selectedCell.row, selectedCell.col, 'center')} className="px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600">
                Center
              </button>
            </div>
          </div>
        )}
        
        <div className={`${cardBg} rounded-lg shadow-lg p-4 md:p-6`}>
          <h2 className={`text-xl font-semibold ${textClass} mb-4`}>Table Preview</h2>
          <div className="overflow-x-auto">
            <table className={`w-full border-collapse border ${darkMode ? 'border-gray-600' : 'border-gray-300'}`}>
              <thead>
                <tr className={darkMode ? 'bg-gray-700' : 'bg-gray-100'}>
                  <th className={`border ${darkMode ? 'border-gray-600' : 'border-gray-300'} px-2 md:px-4 py-2 text-sm`}>#</th>
                  {headers.map((h, i) => (
                    <th key={i} className={`border ${darkMode ? 'border-gray-600' : 'border-gray-300'} px-2 md:px-4 py-2 text-sm`}>
                      <div className="flex items-center justify-between gap-2">
                        <input
                          type="text"
                          value={h}
                          onChange={(e) => {
                            const newHeaders = [...headers];
                            newHeaders[i] = e.target.value;
                            setHeaders(newHeaders);
                          }}
                          className={`flex-1 px-2 py-1 text-center bg-transparent ${textClass}`}
                        />
                        <button onClick={() => sortColumn(i)} className="text-xs hover:text-blue-500">â†•</button>
                        <button onClick={() => deleteColumn(i)} className="text-xs text-red-500 hover:text-red-700">
                          <Trash2 size={14} />
                        </button>
                      </div>
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {filteredData.map(({ row, idx }) => (
                  <tr key={idx} className={darkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-50'}>
                    <td className={`border ${darkMode ? 'border-gray-600 bg-gray-700' : 'border-gray-300 bg-gray-50'} px-2 md:px-4 py-2 text-center font-medium text-sm`}>
                      <div className="flex items-center justify-center gap-2">
                        {idx + 1}
                        <button onClick={() => deleteRow(idx)} className="text-xs text-red-500 hover:text-red-700">
                          <Trash2 size={14} />
                        </button>
                      </div>
                    </td>
                    {row.map((cell, colIdx) => (
                      <td key={colIdx} className={`border ${darkMode ? 'border-gray-600' : 'border-gray-300'} px-2 md:px-4 py-2 text-sm`}>
                        <input
                          type="text"
                          value={cell}
                          onChange={(e) => {
                            const newData = [...data];
                            newData[idx][colIdx] = e.target.value;
                            setData(newData);
                          }}
                          onFocus={() => setSelectedCell({ row: idx, col: colIdx })}
                          style={getCellStyle(idx, colIdx)}
                          className={`w-full px-2 py-1 bg-transparent ${textClass}`}
                        />
                      </td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  );
}

export default TableGenerator;
